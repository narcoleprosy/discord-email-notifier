import discord
import asyncio
import imaplib
import email
import os
from discord.ext import commands

# Email settings
IMAP_SERVER = 'imap.example.com' #Replace with your email's imap address. Easily googleable.
EMAIL_ACCOUNT = 'put@emailaddress.here' #Replace with the email address you want monitored
PASSWORD = 'password' # If using gmail, you will need to set up an app password.

# Discord bot settings
DISCORD_TOKEN = 'Discord Token' #Replace with the discord bot token generated by discord.

# File to store processed email IDs and thread ID
PROCESSED_EMAILS_FILE = 'processed_emails.txt'
THREAD_ID_FILE = 'thread_id.txt'

# Set up Discord client with intents
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.guild_messages = True
bot = commands.Bot(command_prefix="^", intents=intents)

# Define your guild and channel IDs
GUILD_ID = 0000000000000000000
CHANNEL_ID = 0000000000000000000
ROLE_ID = 0000000000000000000 # If you want this to ping a role when a new email comes in, replace with that role ID

# Adjusted intervals
EMAIL_CHECK_INTERVAL = 900
THREAD_UPDATE_INTERVAL = 300
INITIAL_CHECK_DURATION = 60

def load_processed_emails():
    if os.path.exists(PROCESSED_EMAILS_FILE):
        with open(PROCESSED_EMAILS_FILE, 'r') as file:
            return set(line.strip() for line in file)
    return set()

def save_processed_email(email_id):
    with open(PROCESSED_EMAILS_FILE, 'a') as file:
        file.write(email_id + '\n')

def load_thread_id():
    if os.path.exists(THREAD_ID_FILE):
        with open(THREAD_ID_FILE, 'r') as file:
            return file.read().strip()
    return None

def save_thread_id(thread_id):
    with open(THREAD_ID_FILE, 'w') as file:
        file.write(str(thread_id))

def check_email(processed_emails):
    new_emails = []
    try:
        mail = imaplib.IMAP4_SSL(IMAP_SERVER)
        mail.login(EMAIL_ACCOUNT, PASSWORD)
        mail.select('inbox')

        status, data = mail.search(None, 'UNSEEN')
        if status != 'OK':
            return new_emails

        email_ids = data[0].split()
        if not email_ids:
            return new_emails

        for email_id in email_ids:
            email_id_str = email_id.decode()
            if email_id_str in processed_emails:
                continue

            status, msg_data = mail.fetch(email_id, '(RFC822)')
            if status != 'OK':
                continue

# What you want the notification to say. This is set up to ping a role with only the subject, which will likely be the shortest and most direct information you need this bot for. 
# You can use other message headers like 'From', 'To', etc. if you find those to be pertinent to your application.
            msg = email.message_from_bytes(msg_data[0][1])
            subject = msg.get('Subject')
            email_info = f"<@&{ROLE_ID}> **New Email:** {subject}" 
            new_emails.append((email_id_str, email_info))

            save_processed_email(email_id_str)

        mail.logout()
    except Exception as e:
        print(f"Error checking email: {e}")
    
    return new_emails

async def send_email_notifications(email_infos):
    channel = bot.get_channel(CHANNEL_ID)
    for _, email_info in email_infos:
        try:
            await channel.send(email_info)
        except discord.HTTPException as e:
            if e.code == 429:
                await asyncio.sleep(60)
            else:
                print(f"Failed to send message: {e}")

async def update_thread_name(thread, countdown_time):
    try:
        while countdown_time > 0:
            minutes, seconds = divmod(countdown_time, 60)
            await thread.edit(name=f"Next update in: {minutes:02}:{seconds:02}")
            await asyncio.sleep(THREAD_UPDATE_INTERVAL)
            countdown_time -= THREAD_UPDATE_INTERVAL
    except discord.HTTPException as e:
        if e.code == 429:
            await asyncio.sleep(60)
        else:
            print(f"Failed to update thread name: {e}")

async def check_and_notify():
    processed_emails = load_processed_emails()
    channel = bot.get_channel(CHANNEL_ID)

    new_emails = check_email(processed_emails)
    if new_emails:
        await send_email_notifications(new_emails)

    thread_id = load_thread_id()
    if thread_id:
        try:
            thread = discord.utils.get(channel.threads, id=int(thread_id))
            if not thread:
                thread = await channel.create_thread(name="Next update in: 30:00", type=discord.ChannelType.public_thread)
                save_thread_id(thread.id)
        except discord.NotFound:
            thread = await channel.create_thread(name="Next update in: 30:00", type=discord.ChannelType.public_thread)
            save_thread_id(thread.id)
    else:
        thread = await channel.create_thread(name="Next update in: 30:00", type=discord.ChannelType.public_thread)
        save_thread_id(thread.id)

    await update_thread_name(thread, EMAIL_CHECK_INTERVAL)
    await asyncio.sleep(INITIAL_CHECK_DURATION)

    while True:
        await asyncio.sleep(EMAIL_CHECK_INTERVAL)
        new_emails = check_email(processed_emails)
        if new_emails:
            await send_email_notifications(new_emails)
        await update_thread_name(thread, EMAIL_CHECK_INTERVAL)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user}')
    bot.loop.create_task(check_and_notify())

# Commands
@bot.tree.command(name="setinterval", description="Set the email check interval")
async def setinterval(interaction: discord.Interaction, interval: int):
    global EMAIL_CHECK_INTERVAL
    EMAIL_CHECK_INTERVAL = interval
    await interaction.response.send_message(f"Email check interval set to {interval} seconds.", ephemeral=True)
@bot.tree.command(name="push", description="Manually check for new emails right now")
async def push(interaction: discord.Interaction):
    await interaction.response.send_message("Checking for new emails...", ephemeral=True)
    processed_emails = load_processed_emails()
    new_emails = check_email(processed_emails)
    if new_emails:
        await send_email_notifications(new_emails)
    else:
        await interaction.followup.send("No new emails found.", ephemeral=True)


async def setup_hook():
    bot.tree.copy_global_to(guild=discord.Object(id=GUILD_ID))
    await bot.tree.sync(guild=discord.Object(id=GUILD_ID))

bot.setup_hook = setup_hook
bot.run(DISCORD_TOKEN)